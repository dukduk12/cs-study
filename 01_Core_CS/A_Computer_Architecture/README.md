## 📖 Computer Architecture Outline
> **본질** : 컴퓨터 구조는 "느린 데이터 이동(I/O, Memory)"을 "빠른 연산(CPU)"에 맞추기 위해 탄생한 시스템

<p align="center">
  <img src="../../00_Docs/가_Images/computer-science.png" alt="computer architecture overview" width="600">
</p>

<p align="center">
  <em>Figure 1. Big Picture of Computer Architecture</em>
</p>

---
### 1. Data : 의미가 아닌 '상태'의 기록
> 컴퓨터는 `의미를 저장하지 않고`, `물리적 상태(0과 1)` 만을 기록함.
> 
> 이 상태의 최소 단위를 `bit`라고 함.

- Bit의 집합 단위 : 
    | 단위       | 크기                      |
    | -------- | ----------------------- |
    | 1 bit    | 0 또는 1                  |
    | 1 nibble | 4 bit                   |
    | 1 byte   | 8 bit                   |
    | 1 word   | CPU 아키텍처 의존 (32/64 bit) |
    > 👉 **메모리는 byte-addressable**인 경우가 대부분 (주소 하나가 1 byte를 가리킴)
---
#### 1.1. Data Representation: Integer & Floating Point
> 컴퓨터는 비트만 저장하며, 정수와 실수의 차이는 `“비트를 해석하는 규칙”`의 차이

- 정수 vs 실수 개요:
    |항목|정수 (Integer)|실수 (Floating Point)|
    |--|--|--|
    |표현 철학|정확성 (Exactly)|범위 (Approximate)|
    |메커니즘|2의 보수 (고정 길이 비트 연산)|IEEE 754 (부호·지수·가수 분리)|
    |오차|없음|반드시 존재 (Precision Error)|
    |비교 연산|`a == b` (안전)|`abs(a - b) < epsilon` (허용 오차 기반 비교 권장)|
    |하드웨어|ALU (산술논리장치)|FPU (부동소수점장치)|
    |결론|용량(범위) 조심|정밀도(오차) 조심|

---
1️⃣ **정수 (Integer)** = 비트 패턴 자체가 값
- 기본 성질
    | 항목    | 설명        |
    | ----- | --------- |
    | 저장 단위 | 고정 길이 비트  |
    | 표현 목표 | **정확한 값** |
    | 소수    | 불가능       |
    | 오차    | 없음        |

- 2진수 vs 16 진수 : 
    | 구분    | 2진수    | 16진수  |
    | ----- | ------ | ----- |
    | 사용 주체 | CPU    | 인간    |
    | 기본 단위 | 1 bit  | 4 bit |
    | 예시    | `0101` | `0x5` |
    > CPU는 2진수로 연산하고, 인간은 16진수로 읽는다.

- 음수 표현 : **`2의 보수`**
    | 단계 | 연산 |
    | -- | -------- |
    | 1  | 모든 비트 반전|
    | 2  | +1  |
    > 덧셈 회로 하나로 뺄셈까지 처리하기 위한 설계

- **`CPU Flag`** (정수 연산 결과의 상태 정보)
    | 플래그 | 의미    |
    | --- | ----- |
    | `ZF`  | 결과가 0 |
    | `SF`  | 음수 여부 |
    | `OF`  | 오버플로우 |
    | `CF`  | 자리올림  |
---
2️⃣ **실수 (Floating Point)** = 비트를 역할별로 분해해 저장한 근사 표현

- 실수의 성질
    | 항목 | 설명 | 
    | :--- | :--- | 
    | 저장 방식 | IEEE 754 표준 (부호,지수,가수) | 
    | 표현 목표 | 넓은 범위의 근사값 | 
    | 한계 | 2진수 변환 시 발생하는 무한 소수 | 
    | 오차 | 정밀도 오차 발생 (Precision Error) |

- 부동소수점 구조 (IEEE 754)
    | 구성 요소    | 역할              |
    | -------- | --------------- |
    | Sign     | 부호 (0: +, 1: -) |
    | Exponent | 소수점 위치 (범위)     |
    | Mantissa | 유효 숫자 (정밀도)     |
---
> 💡 **정수 vs 실수의 차이**
>
> - 정수 -> 계산이 틀리지 않지만, 비트 범위를 넘으면 완전히 다른 값(`Overflow`)이 됨.
> - 실수 ->  매우 큰 수를 표현할 수 있지만,
표현 과정에서 뒷자리가 잘리는 근사 오차(`Precision Loss`) 가 발생

---
#### 1.2. Character Representation: Encoding
> 문자는 숫자로 치환되어 저장되며, 이 대응 규칙을 **Encoding**이라 함.
  - **Encoding**: 문자 → 숫자 (컴퓨터가 저장)
  - **Decoding**: 숫자 → 문자 (사람이 읽음)
---
- Character Encoding 개요 :
    | 인코딩 | 비트 수 | 분류 | 특징 |
    | --------- | --------- | ------ | ----------------------- |
    | ASCII     | 7 (실사용 8) | 단일 바이트 | 영어권 표준, 모든 인코딩의 기반      |
    | EUC-KR    | 16 bit    | 완성형    | KS X 1001 기반, 한글 2,350자 |
    | **CP949** | 16 bit    | 확장 완성형 | EUC-KR 확장, 실질적 한국 표준    |
    | UTF-8     | 1~4 byte  | 유니코드   | 전 세계 표준, 가변 길이          |
---
- ASCII (기초 표준) :
    | 항목    | 설명           |
    | ----- | ------------ |
    | 표현 범위 | 0 ~ 127      |
    | 문자 수  | 128개         |
    | 특징    | 영문자·숫자·기호    |
    | 중요성   | UTF-8과 완전 호환 |
---
- 한글 인코딩의 두 철학 : 완성형 vs 조합형
    | 구분     | 완성형           | 조합형     |
    | ------ | ------------- | ------- |
    | 저장 방식  | 글자 단위         | 자모 단위   |
    | 예시     | `가`, `나`      | `ㄱ + ㅏ` |
    | 구현 난이도 | 낮음            | 높음      |
    | 대표 인코딩 | EUC-KR, CP949 | 유니코드 내부 |
---
- Unicode & UTF-8 :
    |구분|Unicode (번호표)|UTF-8 (배달/저장 방식)|
    | ------ | ------------- | ------- |
    |역할|전 세계 문자에 고유 번호(Code Point) 부여|유니코드를 실제 바이트로 변환하는 규칙|
    |형태|U+AC00 (한글 '가')|0xEA 0xB0 0x80 (UTF-8에서 '가'는 3바이트로 저장됨)|
    |특징|추상적인 규칙 (지도와 같음)|효율적인 가변 길이 (실제 도로와 같음)|
---
### 2. Instruction : 컴퓨터가 일하는 방식
> Instruction은 “CPU에게 **무엇을, 어떤 데이터로, 어디에** 할지”를 지시하는 최소 실행 단위

- **Data**가 *상태*라면
- **Instruction**은 그 상태를 **변화시키는 규칙**
---
#### 2.1. Programming Language & Translation
> 사람이 작성한 코드는 반드시 **CPU가 이해 가능한 명령어**로 번역되어야 함
---
- 언어의 계층 (Abstraction Level)
    | 구분       | 고급 언어 (High-Level) | 저급 언어 (Low-Level) |
    | -------- | ------------------ | ----------------- |
    | 대상       | 인간 중심              | 컴퓨터 중심            |
    | 예시       | Python, C, Java    | 기계어, 어셈블리어        |
    | 가독성      | 높음                 | 낮음                |
    | 하드웨어 의존성 | 낮음                 | 매우 높음             |
    | 핵심 역할    | **의도 표현**          | **직접 제어**         |

    > 💡 **CPU는 오직 기계어만 이해** 나머지는 모두 “번역 편의성”을 위한 계층

- 기계어 vs 어셈블리어 :
    | 구분    | 기계어        | 어셈블리어           |
    | ----- | ---------- | --------------- |
    | 형태    | 0과 1       | 니모닉(MOV, ADD 등) |
    | 실행 주체 | CPU        | 인간              |
    | 관계    | 실제 실행 코드   | 기계어의 1:1 대응 표현  |
    | 예시    | `10101000` | `MOV AX, BX`    |
    > 어셈블리어는 **새 언어가 아니라 라벨링**이다.

- 번역 방식 (Translation Strategy) : 
    | 항목    | Compile      | Interpret          |
    | ----- | ------------ | ------------------ |
    | 번역 시점 | 실행 전         | 실행 중               |
    | 단위    | 전체 코드        | 한 줄씩               |
    | 결과물   | 목적 파일        | 즉시 실행              |
    | 실행 속도 | 빠름           | 느림                 |
    | 개발 편의 | 낮음           | 높음                 |
    | 대표 언어 | C, C++, Rust | Python, JavaScript |
    > ⚠️ Python은 중간 언어 (Bytecode) + JIT 사용

- 목적 파일(Object File) vs 실행 파일(Executable) :
    | 구분    | 목적 파일 (.o) | 실행 파일           |
    | ----- | ---------- | --------------- |
    | 상태    | 미완성        | 완성              |
    | 포함 내용 | 기계어 + 심볼   | 실제 실행 코드        |
    | 링크 필요 | O          | X               |
    | 예시    | `main.o`   | `a.out`, `.exe` |
    > `링커(Linker)`가 여러 목적 파일을 하나로 묶어 실행 파일 생성
---
#### 2.2. Instruction Structure
> **형태가 정해진 비트 패턴**이며, CPU는 이를 해석해 동작함

- Instruction의 기본 구성:
    | 구성 요소           | 역할               |
    | --------------- | ---------------- |
    | Opcode          | 무엇을 할 것인가        |
    | Operand         | 어떤 데이터로 할 것인가    |
    | Addressing Mode | 데이터를 어디서 가져올 것인가 |
    - 예시 : 
        ```sql
        ADD R1, R2
        ```
        | 필드      | 의미           |
        | ------- | ------------ |
        | Opcode  | ADD (덧셈)     |
        | Operand | R1, R2       |
        | 결과      | R1 ← R1 + R2 |

- Addressing Mode (데이터 접근 방식):
    | 방식        | 설명           |
    | --------- | ------------ |
    | Immediate | 값이 명령어에 포함   |
    | Register  | 레지스터 사용      |
    | Direct    | 메모리 주소 직접 지정 |
    | Indirect  | 주소를 가리키는 주소  |
    | Indexed   | 배열 접근에 사용    |
    > 💡 Instruction 성능은 연산보다 “`데이터 접근 방식`”에 좌우됨

- Instruction Cycle (CPU의 일상 루틴):
    | 단계         | 설명       |
    | ---------- | -------- |
    | Fetch      | 명령어 가져오기 |
    | Decode     | 명령어 해석   |
    | Execute    | 연산 수행    |
    | Memory     | 메모리 접근   |
    | Write-back | 결과 저장    |
    - CPU는 이 사이클을 미친 듯이 반복하며, 이 사이클 하나가 **Clock Cycle들의 묶음**
    - 여기서 Clock(클럭) [예. 1초에 3.5GHz]는 이 사이클이 얼마나 빨리 돌아가는지 기준
---
###  📌 Practical Takeaways
| 구분         | 문제 상황 (Example)            | 본질 (What’s happening)    | 해결 원칙 (Solution)                                 |
| ---------- | -------------------------- | ------------------------ | ------------------------------------------------ |
| **실수 연산**  | `0.1`을 10번 더했는데 `1.0`이 안 됨 | 부동소수점은 2진수 **근사값**으로 저장됨 | 금전/정밀 계산은 **정수 단위** 또는 `Decimal / BigDecimal` 사용 |
| **정수 범위**  | ID 값이 갑자기 음수로 바뀜           | 32비트 정수 **오버플로우** 발생     | 처음부터 **64비트 정수(Long/BigInt)** 사용                 |
| **문자 인코딩** | 서버 로그 한글 깨짐                | 환경 간 **인코딩 규칙 불일치**      | 소스·DB·로그 전부 **UTF-8 통일**                         |
| **메모리 접근** | 반복문 추가 후 성능 급락             | 비연속 접근으로 **캐시 미스 증가**    | **연속 메모리 구조** + **순차 접근**                        |
| **대용량 연산** | Python 루프가 지나치게 느림         | 인터프리터 + 잦은 메모리 접근        | **NumPy 벡터화**로 저수준 최적화 활용                        |

> **성능은 메모리 접근 패턴의 문제이고,**
>
> **안전은 비트 표현의 문제이며,**
>
> **호환성은 규격 준수의 문제이다.**