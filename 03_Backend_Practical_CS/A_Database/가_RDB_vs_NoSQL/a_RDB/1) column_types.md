## 📖 Column Types
### 1. Numeric Types
| Type  | 저장 크기  | 범위/정밀도  | 용도/포인트   | 설계 팁   |
| --| -- | -- | -- | -- |
| **TINYINT** | 1 byte | -128 ~ 127 (SIGNED)<br>0 ~ 255 (UNSIGNED) | 상태값, 플래그용 | Boolean/상태값용. DB 호환성 위해 `TINYINT(1)` 사용        |
| **SMALLINT**  | 2 byte      | -32,768 ~ 32,767<br>0 ~ 65,535                         | 작은 수치, 카운터    | 작은 테이블 인덱스, 용량 절약                              |
| **MEDIUMINT**  | 3 byte      | -8,388,608 ~ 8,388,607                                 | 중간 규모 수치      | 큰 테이블에서 PK/FK 용량 고민 시 고려                       |
| **INT / INTEGER** | 4 byte      | -2,147,483,648 ~ 2,147,483,647                         | 일반 PK, 카운터    | 사용자가 급증하면 고갈 가능 → 큰 서비스 PK는 BIGINT 추천          |
| **BIGINT**            | 8 byte      | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 | PK/FK, 큰 수치   | 대규모 서비스 표준 PK. 정렬 성능/인덱스 크기 고려 필요              |
| **DECIMAL / NUMERIC** | 가변(최대 65자리) | 정확한 소수점 저장                                             | 금융, 정산, 가격    | `DECIMAL(19,4)` 권장. 정확한 계산 필수, FLOAT/DOUBLE 금지 |
| **FLOAT**             | 4 byte      | 단정도 부동소수점, ±3.4e38, 7자리 정밀도                            | 과학 계산, 통계     | 근사값 저장. 금융/정산 금지                               |
| **DOUBLE / REAL**     | 8 byte      | 배정도 부동소수점, ±1.7e308, 15~16자리 정밀도                       | 과학/통계, 대규모 계산 | FLOAT보다 정밀, 근사값 저장. 돈 계산 X                     |

> ⚠️ 포인트:
>
> - `INT(11)`의 숫자는 저장 크기가 아니라 출력 시 자릿수. ZEROFILL과 함께 사용 시 출력 자리수 의미
> - 소수점 계산이 필요한 데이터에 `FLOAT/DOUBLE`을 쓰면 부동 소수점 오차로 정산이 틀어짐
> - PK는 대부분 `BIGINT UNSIGNED`, `INT`는 급성장 서비스에서 고갈 위험
> - `TINYINT(1)` → Boolean 호환용
---
### 2. String Types
|Type|특징|사용 전략|
|--|--|--|
|**CHAR(n)**|고정 길이|고정된 코드값(예: ISO 국가코드 2자리, MD5 해시). 검색 속도 미세하게 빠름|
|**VARCHAR(n)**|가변 길이|기본 문자열. `n`은 바이트가 아니라 글자 수(UTF-8 기준)임을 인지|

> ⚠️ 포인트:
>
> - `VARCHAR(255)`는 과거 인덱스 길이 제한(767 byte) 때문에 굳어진 습관으로 실제 필요한 길이만큼만 할당
> - **TEXT** : 인덱스 생성이 불가능하거나 prefix 인덱스만 가능하므로, 조회 조건(WHERE)에 들어가는 칼럼은 X
---
### 3. Temporal Types (Timezone 이슈)
| Type   | 범위   | 특징  | 사용 전략   |
| ------------- | ---------------------- | ----------------------- | --------------------------------- |
| **DATETIME**  | 1000~9999   | 입력값 그대로 저장  | 글로벌 대응 필요 없거나, 어플리케이션에서 UTC 처리 가능 |
| **TIMESTAMP** | 1970~2038  | UTC 저장 후 조회 시 타임존 변환 가능 | 로그, 생성/수정일, 글로벌 서비스에 권장           |
| **DATE**      | 1000-9999   | 날짜만  | 생일, 만료일 등 시간 필요 없는 경우             |
| **TIME**      | -838:59:59 ~ 838:59:59 | 시간만    | 근무시간, 지속시간 기록                     |
| **YEAR**      | 1901~2155   | 연도만  | 통계, 연도별 집계                        |

> ⚠️ 포인트:
>
> - 글로벌 서비스면 DB에는 UTC 저장(`TIMESTAMP`), 조회 시 애플리케이션에서 사용자 타임존 변환
> - `DATETIME`은 서버가 하나고, 글로벌 대응 필요 없으면 그대로 사용 가능
> - `TIMESTAMP` 2038년 문제 주의 → 서비스 수명 고려
---
### 4. Special Types (ENUM & JSON)
- **ENUM**: 초기엔 가독성이 좋으나, 옵션 추가 시 ALTER TABLE이 발생하여 운영 중 대형 테이블이 락(Lock)에 걸릴 수 있음 ⭐
- **JSON**: 스키마가 유동적인 메타데이터 저장엔 좋으나, 내부 데이터를 조건으로 조회하면 성능이 급락함
---
### 5. 컬럼 속성
| 속성  | 설명 | 왜 중요한가 |
| --  | -- | --  |
| **NULL / NOT NULL** | 값이 비어있을 수 있는지 여부 | NULL 허용 컬럼이 많으면 옵티마이저가 쿼리 계획을 모호하게 잡아 성능 저하. NOT NULL + Default 사용 권장 |
| **DEFAULT 값** | 컬럼이 생략될 경우 기본값  | 데이터 일관성 확보, INSERT 시 생략 가능, 옵티마이저 도움 |
| **AUTO_INCREMENT** | 정수형 PK 자동 증가 | PK 생성 용이, 순차 인덱스 → B-Tree 성능 최적화 |
| **UNSIGNED** | 음수 값 허용 여부 | 범위 2배 확장. 예: TINYINT UNSIGNED → 0~255 |
| **PRIMARY / UNIQUE KEY** | 기본키/고유 제약 | 데이터 무결성, 인덱스 구조, 검색 최적화 |
| **INDEX / FULLTEXT / SPATIAL** | 검색 최적화용 인덱스 | 조회 성능 향상. TEXT/JSON 컬럼은 인덱스 제한 있음                                     |
| **CHARSET / COLLATION** | 문자열 인코딩 | UTF-8/UTF-8MB4 등 글로벌 문자 지원, 정렬/검색 결과 정확성 |

> - `UTF-8` 은 이모지를 저장 못 함. 따라서 `UTF-8MB4`을 적절히 사용할 것
> - `NOT NULL`이 아니라면 옵티마이저는 해당 컬럼을 검색할 때 '값이 없는 경우'까지 계산해야 하므로 연산이 복잡
---
### 📌 Summary
1. **PK는?** -> `BIGINT` | 다만, 서비스 성장 예상 규모에 따라 선택
2. **돈은?** -> `DECIMAL` (오차는 소송이다)
3. **상태값은?** -> `TINYINT` (1바이트로 아끼자)
4. **문자열은?** -> `VARCHAR` (TEXT는 웬만하면 피하자)
5. **시간은?** -> `TIMESTAMP` (글로벌 시대니까 UTC)
6. **파일은?** -> URL 문자열만 (DB 무거워지면 이사 힘들다)
---